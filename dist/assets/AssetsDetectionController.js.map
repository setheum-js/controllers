{"version":3,"file":"AssetsDetectionController.js","sourceRoot":"","sources":["../../src/assets/AssetsDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { toChecksumAddress } from 'ethereumjs-util';\nimport contractMap from '@metamask/contract-metadata';\nimport BaseController, { BaseConfig, BaseState } from '../BaseController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport { safelyExecute, timeoutFetch } from '../util';\nimport type { AssetsController, AssetsState } from './AssetsController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { Token } from './TokenRatesController';\n\nconst DEFAULT_INTERVAL = 180000;\nconst MAINNET = 'mainnet';\n\n/**\n * @type ApiCollectibleResponse\n *\n * Collectible object coming from OpenSea api\n *\n * @property token_id - The collectible identifier\n * @property image_original_url - URI of collectible image associated with this collectible\n * @property name - The collectible name\n * @property description - The collectible description\n * @property assetContract - The collectible contract basic information, in this case the address\n */\nexport interface ApiCollectibleResponse {\n  token_id: string;\n  image_original_url: string;\n  name: string;\n  description: string;\n  asset_contract: { [address: string]: string };\n}\n\n/**\n * @type AssetsConfig\n *\n * Assets controller configuration\n *\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface AssetsDetectionConfig extends BaseConfig {\n  interval: number;\n  networkType: NetworkType;\n  selectedAddress: string;\n  tokens: Token[];\n}\n\n/**\n * Controller that passively polls on a set interval for assets auto detection\n */\nexport class AssetsDetectionController extends BaseController<\n  AssetsDetectionConfig,\n  BaseState\n> {\n  private handle?: NodeJS.Timer;\n\n  private getOwnerCollectiblesApi(address: string) {\n    return `https://api.opensea.io/api/v1/assets?owner=${address}&limit=300`;\n  }\n\n  private async getOwnerCollectibles() {\n    const { selectedAddress } = this.config;\n    const api = this.getOwnerCollectiblesApi(selectedAddress);\n    let response: Response;\n    try {\n      const openSeaApiKey = this.getOpenSeaApiKey();\n      /* istanbul ignore if */\n      if (openSeaApiKey) {\n        response = await timeoutFetch(\n          api,\n          { headers: { 'X-API-KEY': openSeaApiKey } },\n          15000,\n        );\n      } else {\n        response = await timeoutFetch(api, {}, 15000);\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return [];\n    }\n    const collectiblesArray = await response.json();\n    const collectibles = collectiblesArray.assets;\n    return collectibles;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'AssetsDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private addTokens: AssetsController['addTokens'];\n\n  private addCollectible: AssetsController['addCollectible'];\n\n  private getAssetsState: () => AssetsState;\n\n  /**\n   * Creates a AssetsDetectionController instance\n   *\n   * @param options\n   * @param options.onAssetsStateChange - Allows subscribing to assets controller state changes\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address\n   * @param options.addTokens - Add a list of tokens\n   * @param options.addCollectible - Add a collectible\n   * @param options.getAssetsState - Gets the current state of the Assets controller\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(\n    {\n      onAssetsStateChange,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      getBalancesInSingleCall,\n      addTokens,\n      addCollectible,\n      getAssetsState,\n    }: {\n      onAssetsStateChange: (\n        listener: (assetsState: AssetsState) => void,\n      ) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addTokens: AssetsController['addTokens'];\n      addCollectible: AssetsController['addCollectible'];\n      getAssetsState: () => AssetsState;\n    },\n    config?: Partial<AssetsDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      networkType: 'mainnet',\n      selectedAddress: '',\n      tokens: [],\n    };\n    this.initialize();\n    this.getAssetsState = getAssetsState;\n    this.addTokens = addTokens;\n    onAssetsStateChange(({ tokens }) => {\n      this.configure({ tokens });\n    });\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const actualSelectedAddress = this.config.selectedAddress;\n      if (selectedAddress !== actualSelectedAddress) {\n        this.configure({ selectedAddress });\n        this.detectAssets();\n      }\n    });\n    onNetworkStateChange(({ provider }) => {\n      this.configure({ networkType: provider.type });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n    this.addCollectible = addCollectible;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval\n   *\n   * @param interval - Polling interval used to auto detect assets\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.detectAssets();\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not\n   *\n   * @returns - Whether current network is mainnet\n   */\n  isMainnet() {\n    if (this.config.networkType !== MAINNET || this.disabled) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Detect assets owned by current account on mainnet\n   */\n  async detectAssets() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    this.detectTokens();\n    this.detectCollectibles();\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet\n   */\n  async detectTokens() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    const tokensAddresses = this.config.tokens.filter(\n      /* istanbul ignore next*/ (token) => token.address,\n    );\n    const tokensToDetect: string[] = [];\n    for (const address in contractMap) {\n      const contract = contractMap[address];\n      if (contract.erc20 && !(address in tokensAddresses)) {\n        tokensToDetect.push(address);\n      }\n    }\n\n    const { selectedAddress } = this.config;\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n    await safelyExecute(async () => {\n      const balances = await this.getBalancesInSingleCall(\n        selectedAddress,\n        tokensToDetect,\n      );\n      const tokensToAdd = [];\n      for (const tokenAddress in balances) {\n        let ignored;\n        /* istanbul ignore else */\n        const { ignoredTokens } = this.getAssetsState();\n        if (ignoredTokens.length) {\n          ignored = ignoredTokens.find(\n            (token) => token.address === toChecksumAddress(tokenAddress),\n          );\n        }\n        if (!ignored) {\n          tokensToAdd.push({\n            address: tokenAddress,\n            decimals: contractMap[tokenAddress].decimals,\n            symbol: contractMap[tokenAddress].symbol,\n          });\n        }\n      }\n      if (tokensToAdd.length) {\n        await this.addTokens(tokensToAdd);\n      }\n    });\n  }\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet\n   * adding new collectibles and removing not owned collectibles\n   */\n  async detectCollectibles() {\n    /* istanbul ignore if */\n    if (!this.isMainnet()) {\n      return;\n    }\n    const { selectedAddress } = this.config;\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n    await safelyExecute(async () => {\n      const apiCollectibles = await this.getOwnerCollectibles();\n      const addCollectiblesPromises = apiCollectibles.map(\n        async (collectible: ApiCollectibleResponse) => {\n          const {\n            token_id,\n            image_original_url,\n            name,\n            description,\n            asset_contract: { address },\n          } = collectible;\n\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredCollectibles } = this.getAssetsState();\n          if (ignoredCollectibles.length) {\n            ignored = ignoredCollectibles.find((c) => {\n              /* istanbul ignore next */\n              return (\n                c.address === toChecksumAddress(address) &&\n                c.tokenId === Number(token_id)\n              );\n            });\n          }\n          /* istanbul ignore else */\n          if (!ignored) {\n            await this.addCollectible(\n              address,\n              Number(token_id),\n              {\n                description,\n                image: image_original_url,\n                name,\n              },\n              true,\n            );\n          }\n        },\n      );\n      await Promise.all(addCollectiblesPromises);\n    });\n  }\n}\n\nexport default AssetsDetectionController;\n"]}